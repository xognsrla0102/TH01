 134 자 이번에는 다른 방법을 사용해서 구현해 봅시다.
이 방법으로 구현하면 플레이도중에 Pause시킬 수도 있고
다시 Resume시킬 수도 있습니다. 물론 중단 시키는 기능도 있습니다.
 135
 136 이 방법을 알아 보기 위해서는
먼저 MCI 디바이스에 대해 알아야 합니다.
MCI라는 것은 간단하게 말해서 어떤 인터페이스 카드를
컴퓨터가 인식하게끔 하는 디바이스입니다.
우리는 이 MCI 디바이스를 이용해서 각종 멀티미디어 파일을 플레이할텐데
이 MCI 디바이스에 대한 것은 자신의 윈도우즈 디렉토리내의 system.ini 파일에
정의 되어 있습니다. 한번 찾아보세요.

 137
 138 [mci]
 139 waveaudio=mciwave.drv
 140 sequencer=mciseq.drv
 141 cdaudio=mcicda.drv
 142 avivideo=mciavi.drv
 143 videodisc=mcipionr.drv
 144 vcr=mcivisca.drv
 145

 146 필자같은 경우에는 위와 같이 되어 있군요. 어떤 문자열이 특수한 디바이스 파일로정의 되어 있죠
우리는 이제 이 앞에 정의된 문자열을 이용해서 각 드라이버를 제어할 것입니다.
확장자가 drv인 파일이 바로 디바이스 드라이브 파일입니다.
 147
 148 이제 부터 우리가 알아볼 함수로 장치 이름을 지정하여
그 핸들(아이디)을 얻어 각종 파일들을 플레이할텐데
이 장치이름에 위에 정의된 waveaudio,

 149 sequencer, cdaudio등을 지정하면 됩니다.
waveaudio라는 것은 wav 파일을 의미하고
sequencer는 midi 파일, cdaudio는 cd 오디오를 의미합니다.

 150

 151 자 그러면 구체적으로 어떤 함수를 이용해서 이러한 것들을 구현할수 있는지 알아봅시다.
우리가 알아볼 것은 웨이브 파일에 대한 것이니 이 파일에 대해 먼저 알아 봅시다.
먼저 MCI 드바이스를 사용하기 위해서는 어떤 파일을 어떤 디바이스 드라이버로 열 것인지
지정해 주어야 합니다. 그래서 성공적으로 열리면 이 파일에 대한 아이디를 얻을 수 있는데
앞으로 이 아이디를 이용해서 플레이하거나 중지하거나 할 수 있습니다.

 152
 153 MCIERROR mciSendCommand(
 154     MCIDEVICEID  IDDevice,
 155     UINT  uMsg,
 156     DWORD  fdwCommand,
 157     DWORD  dwParam
 158    );
 159

 160 앞으로 우리는 이 함수를 많이 사용할 것입니다.
위 함수의 두번째 파라미터에 어떤 예약어를 지정함에 따라 파일을 열 수도 있고
닫을 수도 있으며 플레이할 수도 있습니다.
 161
 162 먼저 첫번째 파라미터에는 MCI 장치의 아이디를 지정하면 되는데
만약에 처음에 여는과정이라면 장치 아이디가 없기 때문에 NULL을 지정하면 됩니다.
그리고 여는 과정에서 얻어진 아이디를 이용해서 다른 작업을 할 때에는 이 얻어진 아이디를
첫번째 파라미터에 지정해 주면 됩니다.
 163

 164 두번째 파라미터에 지정해주는 예약어에 따라
어떤 작업을 할 것인지 구분된다고 했는데
이 두번째 파라미터로 올 수 있는 예약어는 다음과 같습니다.

 165
 166 MCI_OPEN        MCI 장치를 엽니다.
 167 MCI_CLOSE       MCI 장치를 닫습니다.
 168 MCI_PLAY        플레이합니다.
 169 MCI_PAUSE       잠시 중단합니다.
 170 MCI_RESUME      다시 재생합니다.
 171 MCI_STOP        중단합니다.
 172

 173 세번째 파라미터는 두번째 파라미터에
어떤 것이 지정되느냐에 따라 그 의미가 달라지므로
이 부분은 다시 아래에 가서 설명드리겠습니다.
그리고 마지막 파라미터는 어떠한 정보로 구성되어 있는
구조체의 주소가 오는데 이 구조체도 두번째 파라미터에 따라서 달라지니 이것도 아래 부분에서 다시 설명드리겠습니다.
 174

 175 다시 원래대로 돌아와서 MCI 장치를 어떻게 여는지 봅시다.
 176
 177 MCI 장치를 열 때 위 함수의 첫번째 파라미터는 NULL을 지정하면 됩니다.
그리고 두번째 파라미터는 MCI_OPEN을 지정하면 되구요. 그리고 세번째 파라미터에는
MCI_OPEN_TYPE|MCI_OPEN_ELEMENT을 지정하면 됩니다.
여기서 MCI_OPEN_TYPE이라는 것은 마지막 파라미터로 오는 구조체에 지정된
MCI 장치를 사용하겠다는 것을 의미합니다.
MCI_OPEN_ELEMENT는 마지막 파라미터로 오는
구조체에 지정된 파일을 사용하겠다는 것을 의미합니다.

 178

 179 자 위의 설명을 잘 생각해 봅시다.
마지막 파라미터에 오는 구조체에 지정된 정보를 사용하겠다는 의미죠?
그러면 이 부분에 오는 구조체는 어떤 구조체일까요?

 180
 181 typedef struct {
 182     DWORD  dwCallback;
 183     MCIDEVICEID  wDeviceID;
 184     LPCTSTR  lpstrDeviceType;
 185     LPCTSTR  lpstrElementName;
 186     LPCTSTR  lpstrAlias;
 187 } MCI_OPEN_PARMS;

 188
 189 바로 위 구조체가 오게됩니다. 위 구조체 변수를 선언한 다음
파라미터중 lpstrDeviceType에 우리가 앞에서 알아본 웨이브 파일인 waveaudio을 지정해
 190 주고 lpstrElementName에 플레이할 파일이름을 지정해 준 후에 이 구조체를
mciSendCommand()함수의 마지막 파라미터에 지정해 주면 됩니다.
조금 복잡한거 같지만 사실은 간단합니다. 이 함수가 성공적으로 수행되면
위 구조체 멤버중 dwDeviceID에 이 장치의 아이디가 저장됩니다.
앞으로 이 아이디를 다른데서 이용할테니 어떤 변수에 저장해 주어야 겠네요.
 191

 192 MCI 장치를 여는 방법을 알았으니 닫는 방법도 알아 봅시다.
MCI장치를 닫을 때에는 mciSendCommand()함수의 첫번째 파라미터에
장치의 아이디를 지정하고 두번째 파라미터에 MCI_CLOSE를 지정하면 됩니다.
세번째 파라미터에는 MCL_WAIT를 지정하면 되고
마지막 파라미터에는 아래 구조체의 주소를 지정하면 됩니다.
뭐 특별히 구조체 멤버에 어떤 값을 지정한 후에 지정할 필요는 없습니다.

 193
 194 typedef struct {
 195     DWORD  dwCallback;
 196 } MCI_GENERIC_PARMS;
 197


 198 자 이번에는 플레이하는 방법을 알아 봅시다.
역시 이것도 mciSendCommand() 함수를 이용하면 됩니다.
역시 첫번째 파라미터에 장치의 아이디를 지정하고
두번째 파라미터에 MCI_PLAY를 지정하면 됩니다.
세번째 파라미터에는 MCI_NOTIFY 를 지정하는데
이것을 지정하게 되면 연주가 끝났을 때
메인 윈도우에 MM_MCINOTIFY라는 메시지를 전달해 줍니다.
마지막 파라미터에는 아래의 구조체 변수를 지정해주어야 하는데
구조체의 멤버중 dwCallback에 윈도우의 핸들을 넣어준 뒤
mciSendCommand()  함수에 넣어주어야 합니다.

 199
 200 typedef struct {
 201     DWORD  dwCallback;
 202     DWORD  dwFrom;
 203     DWORD  dwTo;
 204 } MCI_PLAY_PARMS;
 205

 206 그러면 플레이되고 있는 것을 잠시 중단하려면 어떻게 할까요. 더 간단합니다.
 207
 208 mciSendCommand() 함수의 첫번째 파라미터에 장치 아이디를 지정하고
두번째 파라미터에 MCI_PAUSE를 지정하면 됩니다. 세번째 파라미터에 MCI_WAIT를 지정하고
마지막 파라미터에 앞에서 알아본 MCI_GENERIC_PARMS 구조체로 선언한 변수의 주소를 지정하면 됩니다.

 209

 210 다시 플레이하려면 두번째 파라미터에 MCI_RESUME를 지정해서 사용하면 됩니다.
아예 중단을 하려면 MCI_STOP을 지정해서 사용하면 되구요.
어때요? 좀 복잡해보입니까? 알고 보면 그렇게 복잡하지도 않습니다.
물론 처음에 알아본 함수만을 이용해서 하는 방법보다는 복잡하죠.
 211

 212 다 그러면 실제로 이러한 함수를 가지고 구현한 프로그램을 보도록 합시다.
아차! 한가지 설명을 빠뜨렸군요. 그것은 플레이되는 위치를 지정하는 것인데
연주가 끝나면 플레이되는 지정을 처음으로 다시 옮길 필요가 있을 겁니다.
이때 다음과 같이  mciSendCommand()함수를 이용하면 됩니다.
 213

 214 먼저 첫번째 파라미터에 장치의 아이디를 지정하고
두번째 파라미터에 MCI_SEEK_TO_START를 지정하면됩니다.
이 두번째 파라미터의 의미가 바로 처음으로 이동한다는 의미입니다.
 215

 216 그리고 마지막 파라미터에 아래와 같은 구조체 변수의 주소를 지정하면 되는데
특별한 곳으로 이동하는 것이 아니기 때문에 초기에 어떤 값을 넣어서 지정할 필요는 없습니다.
만약에 특정한 곳으로 이동하려면 이 구조체의 맴버중 dwTo에 이동할 곳을 지정해 주면 됩니다.

 217
 218 typedef struct {
 219     DWORD  dwCallback;
 220     DWORD  dwTo;
 221 } MCI_SEEK_PARMS;

 222
 227 이번시간에는 저번시간에 알아본 함수들을 이용해서 프로그램을 하나 만들어 보겠습니다.
 228
 229 자 그러면 전체적인 프로그램을 보도록 합시다. 아래는 리소스 파일입니다.
 232
 233 MyMenu MENU
 234 BEGIN
 235     POPUP "&Wave"
 236     BEGIN
 237         MENUITEM "&Play", 100
 238         MENUITEM "P&ause", 200
 239         MENUITEM "&Resume", 300
 240         MENUITEM "&Stop", 400
 241     END
 242 END

 251 DWORD Open(HWND hWnd);
 252 void Play(HWND hWnd, DWORD dwID);
 253 void Stop(HWND hWnd, DWORD dwID);
 254 void Pause(HWND hWnd, DWORD dwID);
 255 void Resume(HWND hWnd, DWORD dwID);
 256 void Close(HWND hWnd, DWORD dwID);
 257 void MoveStartPosition(HWND hWnd, DWORD dwID);

 258

 306 LRESULT CALLBACK

 307 WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)

 308 {

 309         static DWORD dwID;
 310
 311         switch(message)
 312         {
 313             case WM_CREATE :
 314
 315                 dwID = Open(hWnd);
 316                 return 0;
 317
 318             case MM_MCINOTIFY :
 319
 320                 MoveStartPosition(hWnd, dwID);
 321                 return 0;
 322
 323             case WM_COMMAND :
 324
 325                 switch(LOWORD(wParam))
 326                 {
 327                     case 100 :
 328
 329                         Play(hWnd, dwID);
 330                         break;
 331
 332                     case 200 :
 333
 334                         Pause(hWnd, dwID);
 335                         break;
 336
 337                     case 300 :
 338
 339                         Resume(hWnd, dwID);
 340                         break;
 341
 342                     case 400 :
 343
 344                         Stop(hWnd, dwID);
 345                         break;
 346                 }
 347                 return 0;
 348
 349             case WM_DESTROY :
 350
 351                 Close(hWnd, dwID);
 352                 PostQuitMessage(0);
 353                 return 0;
 354         }
 355         return DefWindowProc(hWnd, message, wParam, lParam);
 356 }

 357
 358 DWORD Open(HWND hWnd)
 359 {
 360     MCI_OPEN_PARMS mciOpenParms;
 361     MCIERROR mciError;
 362
 363     mciOpenParms.lpstrDeviceType = "waveaudio";
 364     mciOpenParms.lpstrElementName = "d:\\test.wav";
 365
 366     mciError = mciSendCommand(NULL, MCI_OPEN, MCI_OPEN_TYPE|MCI_OPEN_ELEMENT,
 367         (DWORD)&mciOpenParms);
 368     if(mciError)
 369         MessageBox(hWnd, "Open Error!!", "Error", MB_OK);
 370     return mciOpenParms.wDeviceID;
 371 }
 372

 373 void Play(HWND hWnd, DWORD dwID)
 374 {
 375     MCI_PLAY_PARMS mciPlayParms;
 376     MCIERROR mciError;
 377
 378     mciPlayParms.dwCallback = (DWORD)hWnd;
 379     mciError = mciSendCommand(dwID, MCI_PLAY, MCI_NOTIFY,
 380         (DWORD)&mciPlayParms);
 381     if(mciError)
 382         MessageBox(hWnd, "Play Error!!", "Error", MB_OK);
 383 }
 384

 385 void Stop(HWND hWnd, DWORD dwID)
 386 {
 387     MCI_GENERIC_PARMS mciGenericParms;
 388     MCIERROR mciError;
 389
 390     mciError = mciSendCommand(dwID, MCI_STOP, MCI_WAIT,
 391         (DWORD)&mciGenericParms);
 392     if(mciError)
 393         MessageBox(hWnd, "Stop Error!!", "Error", MB_OK);
 394 }
 395

 396 void Pause(HWND hWnd, DWORD dwID)
 397 {
 398     MCI_GENERIC_PARMS mciGenericParms;
 399     MCIERROR mciError;
 400
 401     mciError = mciSendCommand(dwID, MCI_PAUSE, MCI_WAIT,
 402         (DWORD)&mciGenericParms);
 403     if(mciError)
 404         MessageBox(hWnd, "Pause Error!!", "Error", MB_OK);
 405 }
 406

 407 void Resume(HWND hWnd, DWORD dwID)
 408 {
 409     MCI_GENERIC_PARMS mciGenericParms;
 410     MCIERROR mciError;
 411
 412     mciError = mciSendCommand(dwID, MCI_RESUME, MCI_WAIT,
 413         (DWORD)&mciGenericParms);
 414     if(mciError)
 415         MessageBox(hWnd, "Resume Error!!", "Error", MB_OK);
 416 }
 417

 418 void Close(HWND hWnd, DWORD dwID)
 419 {
 420     MCI_GENERIC_PARMS mciGenericParms;
 421     MCIERROR mciError;
 422
 423     mciError = mciSendCommand(dwID, MCI_CLOSE, MCI_WAIT,
 424         (DWORD)&mciGenericParms);
 425     if(mciError)
 426         MessageBox(hWnd, "Resume Error!!", "Error", MB_OK);
 427 }
 428

 429 void MoveStartPosition(HWND hWnd, DWORD dwID)
 430 {
 431     MCI_SEEK_PARMS mciSeekParms;
 432     MCIERROR mciError;
 433
 434     mciError = mciSendCommand(dwID, MCI_SEEK, MCI_SEEK_TO_START,
 435         (DWORD)&mciSeekParms);
 436     if(mciError)
 437         MessageBox(hWnd, "Set Length Format Error!!", "Error", MB_OK);
 438 }

 439
 440 어떻게 돌아가는지 짐작이 갑니까? 별로 어렵지 않죠?
에러 처리하는 부분만 새롭지 크게 어려운 점은 없을 겁니다.
이부분은 다음 시간에 설명 드리도록 하겠습니다.



 444 이번시간에는 저번시간에 본 프로그램을 분석해 보겠습니다. 그리고 플레이하는 또 다른 방법도 알아 보겠습니다.

 445

 446 먼저 저번시간에 만들어본 소스를 보도록 합시다.

 447

 448 case WM_CREATE :

 449

 450     dwID = Open(hWnd);

 451     return 0;

 452

 453 윈도우가 생성되었을때에 Open()이라는 함수에 의해서 장치의 아이디를 얻는 과정을 보여 주고 있습니다.

 454

 455 case MM_MCINOTIFY :

 456

 457     MoveStartPosition(hWnd, dwID);

 458     return 0;

 459

 460 이 메시지는 언제 발생됩니까? MCI_PLAY라는 파라미터를 지정해서 사용한 mciSendCommand() 함수를 보면 세번째 파라미터를 MCI_NOTIFY라고 지정했을 겁니다. 그렇죠? 이것에 의해서 연주가 끝나거나 중단되면 바로 위 메시지가 발생됩니다. 플레이가 끝나면 플레이 시작 위치를 처음으로 옮기는 역할을 하는것이 위 MoveStartPosition()함수입니다.

 461

 462 case WM_COMMAND :

 463

 464     switch(LOWORD(wParam))

 465     {

 466         case 100 :

 467

 468             Play(hWnd, dwID);

 469             break;

 470

 471 플레이를 하는 구문입니다.

 472

 473         case 200 :

 474

 475             Pause(hWnd, dwID);

 476             break;

 477

 478 잠시 중단하게 하는 구문입니다.

 479

 480         case 300 :

 481

 482             Resume(hWnd, dwID);

 483             break;

 484

 485 다시 플레이하는 구문입니다.

 486

 487         case 400 :

 488

 489             Stop(hWnd, dwID);

 490             break;

 491

 492 플레이를 중단하는 구문입니다.

 493

 494     }

 495     return 0;

 496

 497 case WM_DESTROY :

 498

 499     Close(hWnd, dwID);

 500     PostQuitMessage(0);

 501     return 0;

 502

 503 프로그램이 종료되면 MCI 장치를 닫는다는 것을 보여 주고 있습니다.

 504

 505 자 그러면 구체적으로 제가 만든 함수들을 보도록 합시다.

 506

 507 DWORD Open(HWND hWnd)

 508 {

 509

 510 이 함수는 MCI 장치를 여는 역할을 하는 함수입니다.

 511

 512     MCI_OPEN_PARMS mciOpenParms;

 513

 514 장치를 열기 위해서는 위 구조체 변수가 필요하다고 이미 설명 드렸을 겁니다.

 515

 516     MCIERROR mciError;

 517

 518 장치가 제대로 열렸는지 확인하기 위해서 위 MCIERROR이라는 변수를 선언한 것입니다.

 519

 520     mciOpenParms.lpstrDeviceType = "waveaudio";

 521

 522 확장자가 wav인 파일을 열기 위해서 디바이스 타입능 waveaudio라고 지정해준 것입니다.

 523

 524     mciOpenParms.lpstrElementName = "d:\\test.wav";

 525

 526 플레이할 파일의 이름을 지정해 주고 있습니다.

 527

 528     mciError = mciSendCommand(NULL, MCI_OPEN, MCI_OPEN_TYPE|MCI_OPEN_ELEMENT,

 529         (DWORD)&mciOpenParms);

 530

 531 실제로 MCI 장치를 여는 과정을 보여 주고 있습니다. 특별한 부분은 없는 것 같군요.

 532

 533     if(mciError)

 534         MessageBox(hWnd, "Open Error!!", "Error", MB_OK);

 535

 536 에러 체크하는 과정이 간단하죠?

 537

 538     return mciOpenParms.wDeviceID;

 539

 540 장치 아이디를 리턴하고 있습니다. 다른 함수에서 이 장치 아이디를 사용할 것입니다.

 541

 542 }

 543

 544 void Play(HWND hWnd, DWORD dwID)

 545 {

 546

 547 이 함수는 플레이 하는 역할을 합니다.

 548

 549     MCI_PLAY_PARMS mciPlayParms;

 550

 551 플레이 하기 위해서는 위 구보체 변수가 필요하죠.

 552

 553     MCIERROR mciError;

 554

 555 역시 에러를 체크하기 위해서 선언한 것입니다.

 556

 557     mciPlayParms.dwCallback = (DWORD)hWnd;

 558

 559 구조체 멤버중 dwCallback에 윈도우의 핸들을 지정해 주고 있습니다.

 560

 561     mciError = mciSendCommand(dwID, MCI_PLAY, MCI_NOTIFY,

 562         (DWORD)&mciPlayParms);

 563

 564 이 구조체를 이용해서 플레이하는 과정을 보여주고 있습니다. 세번째 파라미터에 쓰인 MCI_NOTIFY에 의해서 플레이가 끝나면 윈도우에 MM_MCINOTIFY메시지를 보내 줍니다.

 565

 566     if(mciError)

 567         MessageBox(hWnd, "Play Error!!", "Error", MB_OK);

 568

 569 플레이가 안되면 에러 메시지를 출력하기 위한 구문입니다.

 570

 571 }

 572

 573 void Stop(HWND hWnd, DWORD dwID)

 574 {

 575

 576 이 함수는 플레이를 중지하는 역할을 합니다. 이 함수에 의해서 플레이가 중지 되도 윈도우에 MM_MCINOTIFY메시지를 보냅니다.

 577

 578     MCI_GENERIC_PARMS mciGenericParms;

 579

 580 중지하기 위해서 사용할 함수의 파라미터에 위 구조체 변수가 필요합니다.

 581

 582     MCIERROR mciError;

 583

 584 에러를 체크하기 위한 변수입니다.

 585

 586     mciError = mciSendCommand(dwID, MCI_STOP, MCI_WAIT,

 587         (DWORD)&mciGenericParms);

 588

 589 중지를 하는 과정입니다. 세번째 파라미터에 MCI_WAIT가 지정된다는 것을 기억하시기 바랍니다. 그냥 NULL로 지정해도 아마 같은 결과가 나올 겁니다.

 590

 591     if(mciError)

 592         MessageBox(hWnd, "Stop Error!!", "Error", MB_OK);

 593

 594 중지를 하는 과정에 에러가 있는지 판단하는 구문입니다.

 595

 596 }

 597

 598 void Pause(HWND hWnd, DWORD dwID)

 599 {

 600

 601 이 함수는 연주중에 잠시 중단하는 역할을 하고 있습니다.

 602

 603     MCI_GENERIC_PARMS mciGenericParms;

 604     MCIERROR mciError;

 605

 606     mciError = mciSendCommand(dwID, MCI_PAUSE, MCI_WAIT,

 607         (DWORD)&mciGenericParms);

 608     if(mciError)

 609         MessageBox(hWnd, "Pause Error!!", "Error", MB_OK);

 610

 611 중지하는 구문과 그 쓰임이 크게 다르지는 않군요.

 612

 613 }

 614

 615 void Resume(HWND hWnd, DWORD dwID)

 616 {

 617

 618 이 함수는 잠시 중지된 것을 다시 플레이하는 역할을 하고 있습니다. 물론 중지된 곳부터 다시 플레이됩니다.

 619

 620     MCI_GENERIC_PARMS mciGenericParms;

 621     MCIERROR mciError;

 622

 623     mciError = mciSendCommand(dwID, MCI_RESUME, MCI_WAIT,

 624         (DWORD)&mciGenericParms);

 625     if(mciError)

 626         MessageBox(hWnd, "Resume Error!!", "Error", MB_OK);

 627

 628 사용방법이 같죠?

 629

 630 }

 631

 632 void Close(HWND hWnd, DWORD dwID)

 633 {

 634

 635 이 함수는 MCI 장치를 닫는 역할을 합니다.

 636

 637     MCI_GENERIC_PARMS mciGenericParms;

 638     MCIERROR mciError;

 639

 640     mciError = mciSendCommand(dwID, MCI_CLOSE, MCI_WAIT,

 641         (DWORD)&mciGenericParms);

 642     if(mciError)

 643         MessageBox(hWnd, "Resume Error!!", "Error", MB_OK);

 644

 645 역시 똑같군요.

 646

 647 }

 648

 649 void MoveStartPosition(HWND hWnd, DWORD dwID)

 650 {

 651

 652 이 함수는 플레이 될 위치를 처음으로 옮기는 역할을 합니다.

 653

 654     MCI_SEEK_PARMS mciSeekParms;

 655

 656 위치를 바꾸기 위해서는 위 구조채 변수를 사용한다고 설명 드렸을 겁니다.

 657

 658     MCIERROR mciError;

 659

 660     mciError = mciSendCommand(dwID, MCI_SEEK, MCI_SEEK_TO_START,

 661         (DWORD)&mciSeekParms);

 662

 663 두번째 파라미터의 MCI_SEEK가 위치를 옮기겠다는 의미이고 세번째 파라미터에 쓰인 MCI_SEEK_TO_START가 처음 부분으로 옮긴다는 의미입니다.

 664

 665     if(mciError)

 666         MessageBox(hWnd, "Set Length Format Error!!", "Error", MB_OK);

 667 }

 668

 669 별로 크게 어려운 부분은 없죠? 그러면 확장자가 wav인 파일을 플레이하는 다른 방법을 알아 봅시다. 참 방법이 다양하죠?

 670

 671 이 방법은 문자열을 이용해서 하는 방법인데 상당히 간단합니다. 역시 커다란 과정은 같습니다.
MCI 장치를 열고 플레이하고 나중에 닫고 뭐 그런 과정이죠.
 672
 673 우리는 앞에서 mciSendCommand()라는 함수를 이용해서 위의 모든 과정을 처리했는데
이번에는 mciSendString()이라는 함수를 이용해서 위의 모든 과정을 처리할 것입니다.
 674
 675 MCIERROR mciSendString(
 676     LPCTSTR  lpszCommand,
 677     LPTSTR  lpszReturnString,
 678     UINT  cchReturn,
 679     HANDLE  hwndCallback
 680    );

 681
 682 첫번째 파라미터는 정의된 특별한 문자열을 지정해주면 되는데
이 부분에 어떻게 지정하느냐에 따라 MCI 장치를 열기도 하고 플레이하기도 합니다.
두번째 파라미터는 이 함수를 사용하고 나서 리턴되는 문자열을 저장할 버퍼를 의미하고
세 번째 파라미터는 버퍼의 크기 마지막 파라미터는 윈도우의 핸들을 지정하면 됩니다.

 683
 684 자 그러면 위 함수의 첫번째 파라미터에 어떤 문자열을 지정해서 어떤 작업을 하는지 알아 봅시다.
 685
 686 먼저 MCI 장치를 여는 방법부터 봅시다. MCI 장치를 열기 이해서는
open이라는 문자열을 이용해서 할 수 있습니다.
물론 이 문자열만으로는 불가능하죠. MCI 장치가 어떤 형태이고
또 어떤 파일인지도 같이 지정해 주어야 할 겁니다.
 687
 688 예를들어 볼까요?
 689
 690 open d:\\test.wav type waveaudio alias wavefile
 691

 692 open 다음에 오는 것이 바로 플레이할 파일 이름입니다. 그리고 파일 타입이
어떤 것인지 지정해 주어야 하는데 이때 type이라는 문자열 다음에
그 타입을 지정해 주면 됩니다. 확장자가 wav이니 waveaudio라고 지정해 준 것입니다.
앞에서 한 것과 같죠? 그 다음에 보면 alias라는 문자열이 있는데
이 문자열 다음에 오는 문자열이 우리가 앞에서 알아본 장치 아이디와 같은 역할을 합니다.
무슨 말인지 알겠습니까? 위 예를 보면 앞으로 우리는 wavefile이라는 문자열을 이 장치의 아이디로 사용하겠다는 의미입니다.
 693

 694 자 그러면 여는 방법을 알았으니 닫는 방법도 알아 봅시다.
닫을 때에는 close라는 문자열을 사용하면 됩니다.
close 다음에는 닫을 장치의 아이디를 나타내는 문자열을 지정해 주면 됩니다.
 695
 696 플레이할 때에는 어떤 문자열을 사용할까요? 짐작이 가죠? 바로 play라는 문자열을 사용합니다.
역시 play 다음에 장치 아이디를 의미하는 문자열이 오고 그 다음에 notify라는 문자열이 옵니다.
이 문자열은 어디서 많이 보지 않았습니까? 잘 기억이 나지 않으면 앞 부분을 보세요.
아마 MCI_NOTIFY가 보일겁니다. 물론 그 역할도 같습니다. 플레이가 끝났을때 윈도우에
MM_MCINOTIFY 메시지를 보냅니다. 플레이를 중지할 때에는 stop이라는 문자열을 사용하고
잠시 중단할 때에는 pause 다시 플레이할 때에는 resume이라는 문자열을 사용합니다.
물론 장치 아이디를 의미하는 문자열과 같이 쓰입니다.

 903 이번시간에는 확장자가 mid인 미디 파일을 어떻게 플레이하는지 알아 보겠습니다.
아마 머리가 좋으신 분은 이미 어떻게 구현하는지 짐작을 하고 있을 겁니다.

 904
 905 이곳도 역시 mciSendCommand()함수와 mciSendString()함수 두가지 방법을 이용해서 구현할 수 있습니다.
먼저 저번시간에 알아본 mciSendString()함수를 이용해서 구현하는 방법을 알아 봅시다.
 906
 907 아주 간단합니다. 위에서 사용했던 MCI 장치 이름인 waveaudio 대신에 sequencer 를 사용하면 되는 것입니다.
이 sequencer를 어디서 본 것 같죠? 멀티미디어 처음 부분에서 system.ini 파일을 설명드렸을 때 언급했을 겁니다.
이 문자열이 바로 미디 장치를 의미하는 것입니다. 자 그러면 이것을 이용해서 프로그램을 만들어 봅시다.

1066 전체적으로 웨이브 파일을 플레이할 때와 크게 달라진 점은 없을 겁니다.
그런데 한 가지 이상한 점이 있죠? 바로 잠시중단하는 경우와 다시 플레이하는 기능이 위 프로그램에서 빠져 있습니다.
왜 그럴까요? 우리는 파일을 플레이했을 때 잠시 중단하는 명령어인 pause라는 것을 사용했을 겁니다.
그런데 문제는 이 미디 파일을 플레이할 때 pause문자열을 사용해서 잠시 중단하면
바로 MM_MCINOTIFY 메시지가 발생되는 것입니다. 이 메시지는 stop문자열을 사용해서 정지를 하거나
플레이가 끝났을 때 발생되는 메시지인데 pause 문자열에 의해서 이 메시지가 발생되는 resume 메시지 처리가
정상적으로 되지 않는다는 것입니다. 그렇기 때문에 이 기능을 위 프로그램에서 뺀 것입니다.
대신 이 기능을 추가한 것을 mciSendCommand() 함수를 이용해서 만들어 볼 것입니다.

1101 자 그러면 이번에는 PAUSE기능과 RESUME기능이 있는 미디 플레이를 구현해 봅시다.
이것을 구현할 때 우리는 미디 파일을 플레이해주는 mciSendCommand()함수를 이용해서 구현할 것입니다.
이 함수의 사용방법을 다시 한번 상기 해 보십시요. 생각 납니까?
잘 나지 않으면 조금 앞 부분을 다시 보기 바랍니다. 다시 설명 드리지 않을테니까요.
1102 
1103 전체적인 원리는 간단합니다. MCI_STOP을 사용해서 정지를 시키던 MCI_PAUSE를 이용해서 정지를 시키던지
MM_MCINOTIFY메시지가 발생되니 어느 것에 의해서 이 메시지가 발생되었는지 구분시켜 주어야 합니다.
그래야 각각 처리를 할테니까요. 이 문제는 변수 하나로 간단하게 해결할 수 있습니다.
그래서 만약에 MCI_STOP에의해서 정지가 된거면 우리가 웨이브 파일을 mciSendCommand()함수로
구현할 때와 마찬가지로 플레이될 위치를 처음으로 옮겨주면 되고
그렇지 않고 MCI_PAUSE에 의해서 발생되었다면 현재 플레이된 위치를 얻어서
그 위치로 다시 세팅해주면 됩니다. 그리고 만약에 사용자가 resume을 선택한다면
MCI_RESUME을 이용해서 다시 플레이하는것이 아니라 MCI_PLAY를 이용해서 플레이 해주면 되는 것입니다.
1104 
1105 플레이될 위치를 처음으로 옮기는 방법은 앞에서 알아 보았으니 생략하고
현재 플레이되고 있는 위치와 또 세팅하는 방법을 알아 보도록 합시다.

2003 자 그렇게 크게 어려운 점은 없죠? 그러면 이번에는 멀티미디어 관련 마지막인 확장자가 avi인 파일을 어떻게 플레이하는지 알아 보겠습니다. 여러분들이 앞에서 알아본 것들 중에서 이 부분이 가장 어려울거라고 생각들 수도 있으나 사실 이 부분이 제일 쉽습니다. 간단하게 함수 하나로 모든 기능을 가진 avi 플레이어를 구현할 수 있거든요. 우리가 앞에서 알아본 프로그램은 전부 mmsystem.h라는 헤더파일을 포함시켰고 또 컴파일할 때도 winmm.lib 파일을 같이 묶어서 컴파일했을 겁니다. 그러나 우리가 이제 알아볼 avi 파일을 플레이할 때에는 이 헤더 파일과 라이브러리 파일이 필요 없습니다. 대신 다른 헤더 파일과 라이브러리 파일이 필요합니다. 필요한 헤더 파일은 vfw.h라는 헤더 파일이고 필요한 라이브러리 파일은vfw32.lib입니다. vfw가 뭐의 약자인지 아십니까? 바로 Video For Windows의 약자입니다. 이게 뭔지는 굳이 제가 설명 드리지 않더라도 알겠죠?

2004 

2005 함수 하나로 플레이할수 있다고 했는데 과연 그 함수가 뭘까요?

2006 

2007 HWND VFWAPIV MCIWndCreate(HWND hwndParent, HINSTANCE hInstance,

2008     DWORD dwStyle,LPCSTR szFile);

2009 

2010 바로 위 함수 하나로 avi를 플레이할 수 있는 조그만 윈도우를 만들 수 있습니다. 첫번째 파라미터에 현재 윈도우의 핸들을 지정해야 하고 두번째 파라미터에는 인스턴스 핸들, 세번째 파라미터는 이 윈도우의 속성을 지정해줄 수 있는데 보통 NULL을 지정하면 기본 속성을 사용하겠다는 것을 의미합니다. 마지막 파라미터는 플레이할 avi 파일이름을 지정하면 됩니다. 만약에 NULL로 지정하면 파일을 직접 찾아서 플레이할 수 있게 됩니다.

2011 

2012 위 함수를 이용해서 윈도우를 생성하고 나면 나중에 프로그램 종료시 윈도우를 제거해 주어야 합니다. 이때에는 아래 함수를 이용해서 하면 됩니다.

2013 

2014 void MCIWndDestroy(HWND hwnd);

2015 

2016 그러면 이 두함수를 이용해서 구현한 간단하고 뛰어난 avi 플레이어를 만들어 봅시다.

2017 

2018 #include <windows.h>

2019 #include <string.h>

2020 #include <vfw.h>

2021 

2022 LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

2023 HINSTANCE hInst;

2024 

2025 int WINAPI WinMain

2026 (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszArg, int nCmdShow)

2027 {

2028         static char szAppName[] = "Multimedia Example";

2029         HWND hWnd;

2030         MSG msg;

2031         WNDCLASS WndClass;

2032 

2033         WndClass.style = CS_HREDRAW|CS_VREDRAW;

2034         WndClass.lpfnWndProc = WndProc;

2035         WndClass.cbClsExtra = 0;

2036         WndClass.cbWndExtra = 0;

2037         WndClass.hInstance = hInstance;

2038         WndClass.hIcon = LoadIcon(NULL, IDI_APPLICATION);

2039         WndClass.hCursor = LoadCursor(NULL, IDC_ARROW);

2040         WndClass.hbrBackground = GetStockObject(WHITE_BRUSH);

2041         WndClass.lpszMenuName = "MyMenu";

2042         WndClass.lpszClassName = szAppName;

2043         if(!RegisterClass(&WndClass))

2044                 return FALSE;

2045 

2046         hWnd = CreateWindow(

2047                 szAppName,

2048                 szAppName,

2049                 WS_OVERLAPPEDWINDOW,

2050                 CW_USEDEFAULT,

2051                 CW_USEDEFAULT,

2052                 CW_USEDEFAULT,

2053                 CW_USEDEFAULT,

2054                 NULL,

2055                 NULL,

2056                 hInstance,

2057                 NULL

2058         );

2059 

2060         hInst = hInstance;

2061 

2062         ShowWindow(hWnd, nCmdShow);

2063         UpdateWindow(hWnd);

2064 

2065         while(GetMessage(&msg, NULL, 0, 0))

2066         {

2067             TranslateMessage(&msg);

2068             DispatchMessage(&msg);

2069         }

2070 

2071         return msg.wParam;

2072 }

2073 

2074 LRESULT CALLBACK

2075 WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)

2076 {

2077         HWND hAviWnd;

2078 

2079         switch(message)

2080         {

2081             case WM_CREATE :

2082 

2083                 hAviWnd = MCIWndCreate(

2084                     hWnd,

2085                     hInst,

2086                     NULL,

2087                     "d:\\test.avi"

2088                 );

2089                 return 0;

2090 

2091             case WM_DESTROY :

2092 

2093                 MCIWndDestroy(hAviWnd);

2094                 PostQuitMessage(0);

2095                 return 0;

2096         }

2097         return DefWindowProc(hWnd, message, wParam, lParam);

2098 }

2099 

2100 정말로 간단하죠? 이 소스를 보신 분은 정말 이 프로그램이 avi 파일을 플레이할 수 있는지 의문이 생길 수도 있을 겁니다. 직접 코딩해서 컴파일 해보시기 바랍니다. 간단하게 만들었지만 정말 대단하다는 것을 느낄 겁니다. 그러면 구체적으로 소스를 보도록 하겠습니다.

2101 

2102 #include <vfw.h>

2103 

2104 프로그램 상단에 위 헤더 파일을 포함시켜 줘야 합니다. 물론 컴파일할 때에는 vfw32.lib 파일을 묶어서 해줘야 하구요.

2105 

2106 HWND hAviWnd;

2107 

2108 조그마하게 생성되는 avi 플레이어 윈도우의 핸들을 얻기 위해서 위 변수를 선언했습니다.

2109 

2110 switch(message)

2111 {

2112     case WM_CREATE :

2113 

2114         hAviWnd = MCIWndCreate(

2115             hWnd,

2116             hInst,

2117             NULL,

2118             "d:\\test.avi"

2119         );

2120         return 0;

2121 

2122 윈도우가 생성될때 avi 플레이어 윈도우를 생성하는 구문입니다.

2123 

2124     case WM_DESTROY :

2125 

2126         MCIWndDestroy(hAviWnd);

2127 

2128 윈도우가 종료될때 avi 플레이어 윈도우를 없애는 구문입니다.

2129 

2130         PostQuitMessage(0);

2131         return 0;

2132 }